<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Secure Chat ‚Äî Persistent Keys</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
/* --- styles (–∫–∞–∫ —Ä–∞–Ω—å—à–µ, —Å –ª—ë–≥–∫–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π) --- */
body { font-family: Inter, sans-serif; background: linear-gradient(135deg,#2c003e,#5a006a,#ff5aab); min-height:100vh; color:#f5f5f5; margin:0; display:flex; flex-direction:column; align-items:center;}
h1{margin-top:20px;color:#ffd6f7;text-shadow:0 2px 8px rgba(0,0,0,.5)}
.container{width:92%;max-width:760px;margin:16px auto}
.card{background:rgba(255,255,255,0.1);border-radius:14px;padding:16px;margin-bottom:14px;box-shadow:0 8px 20px rgba(0,0,0,.4);backdrop-filter:blur(4px);transition:transform .18s,box-shadow .18s}
.card:hover{transform:translateY(-2px);box-shadow:0 12px 24px rgba(0,0,0,.6)}
textarea,input{width:100%;box-sizing:border-box;margin:6px 0;padding:10px;border-radius:10px;border:none;background:rgba(255,255,255,.14);color:#fff;font-family:monospace}
button{background:linear-gradient(90deg,#ff5aab,#8a2be2);color:#fff;border:none;border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:600;transition:transform .16s,box-shadow .16s}
button:disabled{opacity:.5;cursor:not-allowed}
button:hover:not(:disabled){transform:translateY(-3px);box-shadow:0 8px 18px rgba(0,0,0,.45)}
#toast-container{position:fixed;top:18px;right:18px;z-index:9999}
.toast{background:rgba(255,255,255,.14);color:#fff;padding:10px 14px;border-radius:10px;margin-top:8px;box-shadow:0 6px 14px rgba(0,0,0,.5);backdrop-filter:blur(3px);transition:opacity .28s,transform .28s;opacity:0;transform:translateY(-12px)}
.footer-icon{width:32px;height:32px;transition:transform .16s;cursor:pointer;margin:18px auto;display:block}
.row{display:flex;gap:8px;flex-wrap:wrap}
.small{font-size:.9rem;color:#e9d6ef;margin-top:6px}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.note{font-size:.82rem;color:#e6d5e9}
</style>
</head>
<body>

<h1>Secure Chat 2.0 üîê</h1>
<div class="container">

  <!-- keys -->
  <div class="card">
    <h2>–ö–ª—é—á–∏ ‚Äî –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ</h2>
    <div class="controls">
      <button id="gen">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—É –∫–ª—é—á–µ–π</button>
      <button id="saveKey" disabled>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á (–ø–∞—Ä–æ–ª—å)</button>
      <button id="loadKey" disabled>–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á (–ø–∞—Ä–æ–ª—å)</button>
      <button id="exportKey" disabled>–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞—à–∏—Ñ—Ä. –∫–ª—é—á</button>
      <input id="importFile" type="file" accept=".json" style="display:none">
      <button id="importKeyBtn">–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞—à–∏—Ñ—Ä. –∫–ª—é—á (—Ñ–∞–π–ª)</button>
    </div>
    <div id="pubArea" style="display:none;margin-top:12px">
      <label>–í–∞—à –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á (–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ):</label>
      <textarea id="myPub" rows="3" readonly></textarea>
      <div class="small">–û—Ç–ø–µ—á–∞—Ç–æ–∫ (SHA256, 16 hex): <code id="myFp"></code></div>
    </div>
    <div class="small note">–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á —Ö—Ä–∞–Ω–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–µ–ª–∞–µ—Ç –µ–≥–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–º –ø–∞—Ä–æ–ª–µ–º.</div>
  </div>

  <!-- peer -->
  <div class="card">
    <h2>–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞</h2>
    <textarea id="peerPub" rows="3" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ (–∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ)"></textarea>
    <div class="controls" style="margin-top:8px">
      <button id="importPeer" disabled>–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á</button>
      <button id="clearPeer">–û—á–∏—Å—Ç–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π –∫–ª—é—á</button>
    </div>
    <div class="small note">–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –Ω–µ —Å–µ–∫—Ä–µ—Ç–µ–Ω ‚Äî –º—ã —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ –ª–æ–∫–∞–ª—å–Ω–æ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞.</div>
    <div class="small">–û—Ç–ø–µ—á–∞—Ç–æ–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞: <code id="peerFp"></code></div>
  </div>

  <!-- encrypt -->
  <div class="card">
    <h2>–®–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</h2>
    <textarea id="plain" rows="3" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"></textarea>
    <div class="controls">
      <button id="encryptBtn" disabled>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      <button id="encryptOnly" disabled>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å (–ø–æ–∫–∞–∑–∞—Ç—å)</button>
    </div>
    <label>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ (—Å–∫–æ–ø–∏—Ä—É–π—Ç–µ/–æ—Ç–ø—Ä–∞–≤—å—Ç–µ):</label>
    <textarea id="cipherout" rows="3" readonly></textarea>
  </div>

  <!-- decrypt -->
  <div class="card">
    <h2>–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</h2>
    <textarea id="cipherin" rows="3" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É (nonce:cipher)"></textarea>
    <div class="controls">
      <button id="decryptBtn" disabled>–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
      <button id="clearOut">–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª—è</button>
    </div>
    <label>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
    <textarea id="plainout" rows="3" readonly></textarea>
  </div>

</div>

<div id="toast-container"></div>

<footer>
  <a href="https://t.me/BluzikArhimew" target="_blank" rel="noopener">
    <img class="footer-icon" src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/telegram.svg" alt="tg">
  </a>
</footer>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

<script>
/*
  Persistent keys enhancement
  - store encrypted private key in localStorage under 'sc_encrypted_priv'
  - store salt and iv in the JSON
  - store peer public key in localStorage under 'sc_peer_pub'
  - functions: saveEncryptedPrivate(pass), loadEncryptedPrivate(pass)
  - UI buttons for save/load/export/import
  - encryption: PBKDF2 -> AES-GCM (WebCrypto)
*/

(async function(){
  const b64 = nacl.util.encodeBase64;
  const fromB64 = nacl.util.decodeBase64;
  const utf8ToU8 = nacl.util.decodeUTF8;
  const u8ToUtf8 = nacl.util.encodeUTF8;

  // helpers
  function toast(msg, t=3000){
    const container = document.getElementById('toast-container');
    if(container.children.length >= 3) container.removeChild(container.children[0]);
    const el = document.createElement('div');
    el.className='toast';
    el.textContent = sanitize(msg);
    container.appendChild(el);
    requestAnimationFrame(()=>{ el.style.opacity='1'; el.style.transform='translateY(0)' });
    setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(-12px)'; el.addEventListener('transitionend', ()=>el.remove()); }, t);
  }
  function sanitize(s){ return String(s).replace(/[<>&"'`]/g,c=>({'<':'<','>':'>','&':'&','"':'"',"'" :"'","`":"`"}[c]||c)); }
  function toBase64(u8){ return b64(u8); }
  function fromBase64(s){ return fromB64(s); }
  function saveLocal(key, val){ localStorage.setItem(key, val); }
  function loadLocal(key){ return localStorage.getItem(key); }
  function removeLocal(key){ localStorage.removeItem(key); }

  // WebCrypto helpers: derive AES key from password via PBKDF2
  async function deriveKeyFromPassword(password, salt, iterations=200000){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({
      name:'PBKDF2',
      salt,
      iterations,
      hash:'SHA-256'
    }, keyMaterial, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
    return key;
  }

  async function encryptSecretKey(secretUint8, password){
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const derived = await deriveKeyFromPassword(password, salt.buffer);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, derived, secretUint8);
    return {
      version:1,
      salt: arrayBufferToB64(salt.buffer),
      iv: arrayBufferToB64(iv.buffer),
      ciphertext: arrayBufferToB64(ct)
    };
  }

  async function decryptSecretKey(jsonObj, password){
    const salt = b64ToArrayBuffer(jsonObj.salt);
    const iv = b64ToArrayBuffer(jsonObj.iv);
    const ct = b64ToArrayBuffer(jsonObj.ciphertext);
    const derived = await deriveKeyFromPassword(password, new Uint8Array(salt));
    const plainBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv:new Uint8Array(iv)}, derived, ct);
    return new Uint8Array(plainBuf);
  }

  function arrayBufferToB64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
  function b64ToArrayBuffer(b64str){ const s = atob(b64str); const arr = new Uint8Array(s.length); for(let i=0;i<s.length;i++) arr[i]=s.charCodeAt(i); return arr.buffer; }

  // UI elems
  const genBtn = document.getElementById('gen');
  const saveKeyBtn = document.getElementById('saveKey');
  const loadKeyBtn = document.getElementById('loadKey');
  const exportKeyBtn = document.getElementById('exportKey');
  const importKeyBtn = document.getElementById('importKeyBtn');
  const importFileInput = document.getElementById('importFile');

  const myPubTA = document.getElementById('myPub');
  const myFp = document.getElementById('myFp');

  const peerPubTA = document.getElementById('peerPub');
  const peerFp = document.getElementById('peerFp');
  const importPeerBtn = document.getElementById('importPeer');
  const clearPeerBtn = document.getElementById('clearPeer');

  const plainTA = document.getElementById('plain');
  const encryptBtn = document.getElementById('encryptBtn');
  const encryptOnlyBtn = document.getElementById('encryptOnly');
  const cipherOutTA = document.getElementById('cipherout');

  const cipherInTA = document.getElementById('cipherin');
  const decryptBtn = document.getElementById('decryptBtn');
  const plainOutTA = document.getElementById('plainout');
  const clearOutBtn = document.getElementById('clearOut');

  // state
  let keyPair = null; // {publicKey:Uint8Array, secretKey:Uint8Array}
  let peerPub = null; // Uint8Array

  // load saved peer key if exists
  const savedPeer = loadLocal('sc_peer_pub_b64');
  if(savedPeer){
    peerPubTA.value = savedPeer;
    try{ peerPub = fromBase64(savedPeer); (async()=>{ peerFp.textContent = await sha256hex(peerPub); importPeerBtn.disabled=false; })(); }catch(e){}
  }

  // load encrypted private existence flag
  const hasEnc = loadLocal('sc_enc_priv_json') !== null;
  if(hasEnc){
    loadKeyBtn.disabled=false; // let user load by password
    exportKeyBtn.disabled=false;
  }

  // helpers: sha256 hex short
  async function sha256hex(u8){
    const h = await crypto.subtle.digest('SHA-256', u8);
    const hex = Array.from(new Uint8Array(h)).map(b=>b.toString(16).padStart(2,'0')).join('');
    return hex.slice(0,32);
  }

  // Generate keys
  genBtn.onclick = async ()=>{
    keyPair = nacl.box.keyPair();
    myPubTA.value = toBase64(keyPair.publicKey);
    myFp.textContent = await sha256hex(keyPair.publicKey);
    // enable save/load buttons
    saveKeyBtn.disabled=false;
    loadKeyBtn.disabled=false;
    exportKeyBtn.disabled=false;
    encryptBtn.disabled = !!peerPub ? false : true;
    encryptOnlyBtn.disabled = encryptBtn.disabled;
    decryptBtn.disabled = false;
    toast('–ö–ª—é—á–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã');
  };

  // Save encrypted private key (ask password)
  saveKeyBtn.onclick = async ()=>{
    if(!keyPair){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∫–ª—é—á–∏'); return; }
    const pass = prompt('–ü—Ä–∏–¥—É–º–∞–π—Ç–µ –ø–∞—Ä–æ–ª—å –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ (–Ω–µ –∫–æ—Ä–æ—Ç–∫–∏–π):');
    if(!pass){ toast('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ'); return; }
    try{
      const obj = await encryptSecretKey(keyPair.secretKey, pass);
      saveLocal('sc_enc_priv_json', JSON.stringify(obj));
      loadKeyBtn.disabled=false;
      exportKeyBtn.disabled=false;
      toast('–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω –ª–æ–∫–∞–ª—å–Ω–æ');
    }catch(e){ console.error(e); toast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–ª—é—á–∞'); }
  };

  // Load encrypted private key (prompt password) ‚Äî will set keyPair.secretKey and publicKey
  loadKeyBtn.onclick = async ()=>{
    const stored = loadLocal('sc_enc_priv_json');
    if(!stored){ toast('–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞'); return; }
    const pass = prompt('–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞:');
    if(!pass){ toast('–ó–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞'); return; }
    try{
      const parsed = JSON.parse(stored);
      const secretU8 = await decryptSecretKey(parsed, pass);
      // reconstruct keyPair: nacl expects secretKey 64 bytes for box.keyPair? tweetnacl.box.keyPair gives 32-byte secretKey (curve25519) but in nacl.box.keyPair secretKey is 32 bytes? In tweetnacl.js secretKey is 32 bytes for box.keyPair
      // Usually nacl.box.keyPair().secretKey is 32 bytes.
      // We need publicKey too: derive from secret
      const pub = nacl.scalarMult.base(secretU8); // curve25519 base
      keyPair = { publicKey: pub, secretKey: secretU8 };
      myPubTA.value = toBase64(keyPair.publicKey);
      myFp.textContent = await sha256hex(keyPair.publicKey);
      toast('–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω –≤ –ø–∞–º—è—Ç—å (—Å–µ–∫—Ä–µ—Ç–Ω–æ)');
      // enable encryption buttons if peer is present
      encryptBtn.disabled = peerPub ? false : true;
      encryptOnlyBtn.disabled = encryptBtn.disabled;
      decryptBtn.disabled = false;
    }catch(e){ console.error(e); toast('–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π –∫–ª—é—á'); }
  };

  // Export encrypted JSON file (download)
  exportKeyBtn.onclick = async ()=>{
    const stored = loadLocal('sc_enc_priv_json');
    if(!stored){ toast('–ù–µ—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞'); return; }
    const blob = new Blob([stored], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'securechat_key.json'; document.body.appendChild(a); a.click();
    a.remove(); URL.revokeObjectURL(url);
    toast('–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω (—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ)');
  };

  // Import encrypted key from file
  importKeyBtn.onclick = ()=> importFileInput.click();
  importFileInput.onchange = async (ev)=>{
    const f = ev.target.files[0];
    if(!f) return;
    const txt = await f.text();
    try{
      JSON.parse(txt); // basic check
      saveLocal('sc_enc_priv_json', txt);
      loadKeyBtn.disabled = false; exportKeyBtn.disabled=false;
      toast('–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ localStorage');
    }catch(e){ toast('–§–∞–π–ª –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç'); }
    importFileInput.value='';
  };

  // Peer key import/auto-save
  peerPubTA.oninput = ()=>{
    // user typing ‚Äî don't auto parse yet; enable import button
    importPeerBtn.disabled = peerPubTA.value.trim() === '';
  };
  importPeerBtn.onclick = async ()=>{
    const s = peerPubTA.value.trim();
    if(!s){ toast('–í—Å—Ç–∞–≤—å—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á'); return; }
    try{
      const arr = fromBase64(s);
      peerPub = arr;
      saveLocal('sc_peer_pub_b64', s); // autosave
      peerFp.textContent = await sha256hex(peerPub);
      importPeerBtn.disabled = false;
      encryptBtn.disabled = keyPair ? false : true;
      encryptOnlyBtn.disabled = encryptBtn.disabled;
      toast('–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
      peerPubTA.value='';
    }catch(e){ toast('–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á'); }
  };
  clearPeerBtn.onclick = ()=>{
    peerPub = null;
    removeLocal('sc_peer_pub_b64');
    peerPubTA.value=''; peerFp.textContent='';
    encryptBtn.disabled = true; encryptOnlyBtn.disabled = true;
    toast('–°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —É–¥–∞–ª—ë–Ω');
  };

  // encryption / decryption
  encryptBtn.onclick = async ()=>{
    if(!keyPair || !peerPub){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π/–∑–∞–≥—Ä—É–∑–∏ –∫–ª—é—á –∏ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–π –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞'); return; }
    let text = (plainTA.value||'').trim();
    if(!text){ toast('–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'); return; }
    if(text.length > 3000){ toast('–°–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ'); return; }
    // sanitize only for output display; encryption uses raw text bytes
    const nonce = nacl.randomBytes(24);
    const encrypted = nacl.box(nacl.util.decodeUTF8(text), nonce, peerPub, keyPair.secretKey);
    const token = toBase64(nonce)+':'+toBase64(encrypted);
    cipherOutTA.value = token;
    // copy to clipboard
    try{ await navigator.clipboard.writeText(token); toast('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –∏ –≥–æ—Ç–æ–≤–æ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ'); } catch(e){ toast('–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ ‚Äî —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –≤—Ä—É—á–Ω—É—é'); }
    plainTA.value=''; // clear input
  };

  encryptOnlyBtn.onclick = ()=> {
    // same but don't copy
    if(!keyPair || !peerPub){ toast('–ö–ª—é—á–∏ –Ω–µ –≥–æ—Ç–æ–≤—ã'); return; }
    let text = (plainTA.value||'').trim();
    if(!text){ toast('–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'); return; }
    const nonce = nacl.randomBytes(24);
    const encrypted = nacl.box(nacl.util.decodeUTF8(text), nonce, peerPub, keyPair.secretKey);
    cipherOutTA.value = toBase64(nonce)+':'+toBase64(encrypted);
    toast('–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ (–ø–æ–∫–∞–∑–∞–Ω–æ –≤ –ø–æ–ª–µ)');
    plainTA.value='';
  };

  decryptBtn.onclick = ()=>{
    if(!keyPair){ toast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á'); return; }
    const data = (cipherInTA.value||'').trim();
    if(!data){ toast('–í—Å—Ç–∞–≤—å—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É'); return; }
    try{
      const parts = data.split(':');
      if(parts.length < 2) throw new Error('invalid');
      const nonce = fromBase64(parts[0]);
      const cipher = fromBase64(parts[1]);
      // We need sender's public key: in NaCl.box scheme the sender used their secret and receiver's public
      // For our UI we use peerPub as the other's public ‚Äî but when decrypting a message sent to you by someone,
      // the 'peerPub' should be the sender's public key. This design assumes you imported sender's public key earlier.
      if(!peerPub){ toast('–°–Ω–∞—á–∞–ª–∞ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è'); return; }
      const plainU8 = nacl.box.open(cipher, nonce, peerPub, keyPair.secretKey);
      if(!plainU8) throw new Error('decrypt-failed');
      plainOutTA.value = u8ToUtf8(plainU8);
      cipherInTA.value='';
      toast('–°–æ–æ–±—â–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ');
    }catch(e){ console.error(e); toast('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å ‚Äî –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á–∏/—Ñ–æ—Ä–º–∞—Ç'); }
  };

  clearOutBtn.onclick = ()=>{ plainTA.value=''; cipherOutTA.value=''; cipherInTA.value=''; plainOutTA.value=''; toast('–ü–æ–ª—è –æ—á–∏—â–µ–Ω—ã'); };

  // small accessibility: enable/disable buttons based on state
  function refreshButtons(){ 
    saveKeyBtn.disabled = !keyPair;
    loadKeyBtn.disabled = loadLocal('sc_enc_priv_json') ? false : true;
    exportKeyBtn.disabled = loadLocal('sc_enc_priv_json') ? false : true;
    importPeerBtn.disabled = peerPubTA.value.trim()==='';
    encryptBtn.disabled = !(keyPair && peerPub);
    encryptOnlyBtn.disabled = encryptBtn.disabled;
    decryptBtn.disabled = !keyPair;
  }
  setInterval(refreshButtons, 800);

  // derive public from secret (utility) - note: tweetnacl provides scalarMult.base
  // Already used above via nacl.scalarMult.base

})();
</script>

</body>
</html>
