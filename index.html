<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>Secure Hax Messenger üí¨üîê</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí¨</text></svg>">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#ff5aab">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Secure Hax">
<meta name="mobile-web-app-capable" content="yes">
<meta name="application-name" content="Secure Hax Messenger">
<meta name="description" content="–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä —Å end-to-end —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏">
<meta name="keywords" content="messenger, secure, encrypted, chat, privacy, pwa">
<meta property="og:title" content="Secure Hax Messenger">
<meta property="og:description" content="–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä —Å end-to-end —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º">
<meta property="og:type" content="website">
<meta property="og:image" content="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%23ff5aab' rx='100'/><text x='256' y='330' text-anchor='middle' font-size='256' fill='white'>üí¨</text></svg>">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<canvas id="particle-canvas"></canvas>
<button id="menu-btn">‚ò∞ –ú–µ–Ω—é</button>
<nav id="nav-menu">
  <button onclick="showPage('home')" class="active" data-page="home">üè† –ì–ª–∞–≤–Ω–∞—è</button>
  <button onclick="showPage('chat')" data-page="chat">üí¨ –ß–∞—Ç</button>
  <button onclick="showPage('setup')" data-page="setup">üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∞</button>
</nav>
<!-- Room Status Indicator -->
<div class="room-status-indicator" id="room-status">
  <div class="room-status-ball" id="status-ball"></div>
  <span class="room-name" id="status-room-name">...</span>
  <span class="participants-count" id="status-participants"></span>
</div>

<div class="container">
  <!-- HOME PAGE -->
  <div id="home-page" class="page active">
    <h1 class="scroll-reveal">üîê Secure Hax Messenger</h1>
    
    <div class="card scroll-reveal">
      <h2>üí¨ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —á–∞—Ç –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏</h2>
      <p>–û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ—Ö–≤–∞—Ç–∏—Ç—å. –î–∞–∂–µ —Å–µ—Ä–≤–µ—Ä –Ω–µ –∑–Ω–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è –≤–∞—à–∏—Ö –ø–µ—Ä–µ–ø–∏—Å–æ–∫.</p>
    </div>

    <div class="card scroll-reveal">
      <h3>üîë End-to-End —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h3>
      <p>–í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è —à–∏—Ñ—Ä—É—é—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ –≤ –±—Ä–∞—É–∑–µ—Ä–µ —Å –ø–æ–º–æ—â—å—é <strong>TweetNaCl</strong> ‚Äî –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –∫–æ—Ç–æ—Ä—É—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Signal.</p>
    </div>

    <div class="card scroll-reveal">
      <h3>üéÆ –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏</h3>
      <p>–ò–≥—Ä–∞–π—Ç–µ –≤ "–ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞" —Å –¥—Ä—É–∑—å—è–º–∏ –ø—Ä—è–º–æ –≤ —á–∞—Ç–µ, –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏—Å—Ç–µ–º—É —Å—Ç–∞–≤–æ–∫ –∏ —Å—á—ë—Ç–∞!</p>
    </div>

    <div class="card scroll-reveal">
      <h3>üé§ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∑–≤–æ–Ω–∫–∏</h3>
      <p>–ó–∞–ø–∏—Å—ã–≤–∞–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–¥–Ω–∏–º –∫–ª–∏–∫–æ–º. –°–æ–≤–µ—Ä—à–∞–π—Ç–µ –∞—É–¥–∏–æ–∑–≤–æ–Ω–∫–∏ —á–µ—Ä–µ–∑ WebRTC!</p>
    </div>

    <div class="card scroll-reveal">
      <h3>üì± –ú–æ–±–∏–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è</h3>
      <p>–ü–æ–ª–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º, –∂–µ—Å—Ç–∞–º–∏ –∏ PWA-–ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞ –≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω.</p>
    </div>

    <div class="card scroll-reveal">
      <h3>üåç –ë–µ–∑ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏</h3>
      <p>–ù–∏–∫–∞–∫–∏—Ö –Ω–æ–º–µ—Ä–æ–≤ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤, email –∏–ª–∏ –ø–∞—Ä–æ–ª–µ–π. –ü—Ä–æ—Å—Ç–æ —Å–æ–∑–¥–∞–π—Ç–µ –∫–æ–º–Ω–∞—Ç—É –∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –∫–æ–¥–æ–º!</p>
    </div>

    <div class="card scroll-reveal">
      <h2>‚ö° –ö–∞–∫ –Ω–∞—á–∞—Ç—å?</h2>
      <ol style="padding-left: 20px; margin-top: 15px;">
        <li style="margin-bottom: 10px;">–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤–æ –≤–∫–ª–∞–¥–∫—É <strong>üí¨ –ß–∞—Ç</strong></li>
        <li style="margin-bottom: 10px;">–°–æ–∑–¥–∞–π—Ç–µ –∫–æ–º–Ω–∞—Ç—É –∏ –ø–æ–ª—É—á–∏—Ç–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–æ–¥ (–Ω–∞–ø—Ä–∏–º–µ—Ä: <code>HAX-A1B2C3</code>)</li>
        <li style="margin-bottom: 10px;">–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å –∫–æ–¥–æ–º —Å –¥—Ä—É–≥–æ–º</li>
        <li style="margin-bottom: 10px;">–î–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è (üü¢ <strong>–ü–æ–¥–∫–ª—é—á–µ–Ω–æ!</strong>)</li>
        <li>–û–±—â–∞–π—Ç–µ—Å—å –±–µ–∑–æ–ø–∞—Å–Ω–æ!</li>
      </ol>
    </div>

    <div class="card scroll-reveal" style="text-align: center;">
      <h2>üîê –í–∞–∂–Ω–æ –∑–Ω–∞—Ç—å</h2>
      <p style="text-align: left;">üìå <strong>–ù–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è:</strong> –ü–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –∫–æ–º–Ω–∞—Ç—ã –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è —É–¥–∞–ª—è—é—Ç—Å—è –Ω–∞–≤—Å–µ–≥–¥–∞.</p>
      <p style="text-align: left; margin-top: 10px;">üìå <strong>–û–¥–∏–Ω –∫–æ–¥ = –æ–¥–Ω–∞ –ø–∞—Ä–∞:</strong> –ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –æ–±—â–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ <strong>–æ–¥–Ω–æ–π –ø–∞—Ä—ã</strong> —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–≤.</p>
      <p style="text-align: left; margin-top: 10px;">üìå <strong>–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å:</strong> –ù–µ –ø—É–±–ª–∏–∫—É–π—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã –≤ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–∞—Ö.</p>
    </div>

    <div class="card scroll-reveal">
      <h3>üîß –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏</h3>
      <p><strong>TweetNaCl</strong> ‚Äî –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è —É—Ä–æ–≤–Ω—è Signal. <strong>Firebase</strong> ‚Äî —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏. <strong>WebRTC</strong> ‚Äî –≥–æ–ª–æ—Å–æ–≤—ã–µ –∑–≤–æ–Ω–∫–∏ P2P.</p>
    </div>

    <div class="card scroll-reveal" style="text-align: center; background: linear-gradient(135deg, rgba(255,90,171,0.2), rgba(138,43,226,0.2));">
      <h2>üéâ –ü–∞—Å—Ö–∞–ª–∫–∏</h2>
      <p>üëÜ –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ <strong>"Sans"</strong> –≤–Ω–∏–∑—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã <strong>3 —Ä–∞–∑–∞</strong> –¥–ª—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞!</p>
      <p style="margin-top: 10px;">üí¨ –í–≤–µ–¥–∏—Ç–µ <strong>"socks"</strong> –≤ —á–∞—Ç–µ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞!</p>
    </div>
  </div>

  <!-- CHAT PAGE -->
  <div id="chat-page" class="page">
    <h1>üí¨ –ß–∞—Ç</h1>

    <div id="room-setup" class="card">
      <h2>üì± –ö–æ–º–Ω–∞—Ç–∞</h2>
      <p>–°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—É—é –∫–æ–º–Ω–∞—Ç—É –∏–ª–∏ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ—Å—å –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ø–æ –∫–æ–¥—É.</p>
      <div id="room-code-display" style="display: none;" onclick="copyRoomCode()">
        –ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
      </div>
      <div class="row" style="justify-content: center; margin-top: 15px;">
        <button id="create-room-btn">‚ú® –°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
      </div>
      <div class="row" style="justify-content: center; margin-top: 10px;">
        <input type="text" id="join-room-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã" style="max-width: 200px; text-align: center; text-transform: uppercase;">
        <button id="join-room-btn">üîó –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
      </div>
    </div>

    <div class="chat-status" id="chat-status" style="display: none;">
      ‚è≥ –û–∂–∏–¥–∞–µ—Ç—Å—è —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫...
    </div>

    <div id="chat-messages" style="display: none;">
      <div class="typing-indicator" id="typing-indicator">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>

    <div class="chat-input-area" id="chat-input-area" style="display: none;">
      <button id="voice-btn" title="üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"><i class="fas fa-microphone"></i></button>
      <input type="text" id="chat-input" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..." style="margin: 0;">
      <button id="send-btn" title="üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å"><i class="fas fa-paper-plane"></i></button>
      <button id="call-btn" title="üìû –ü–æ–∑–≤–æ–Ω–∏—Ç—å"><i class="fas fa-phone"></i></button>
    </div>
  </div>

  <!-- SETUP PAGE -->
  <div id="setup-page" class="page">
    <h1>üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–ª—é—á–µ–π</h1>
    
    <div class="card">
      <h2>üîê –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏</h2>
      <p>–í–∞—à–∏ –∫–ª—é—á–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ –≤ –±—Ä–∞—É–∑–µ—Ä–µ –∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä. –ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–π –∫–æ–º–Ω–∞—Ç—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –Ω–æ–≤–∞—è –ø–∞—Ä–∞ –∫–ª—é—á–µ–π.</p>
      
      <div class="key-display" id="key-info" style="display: none;">
        <label>–í–∞—à –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á (BASE64):</label>
        <textarea id="pub-key-display" rows="3" readonly onclick="this.select()"></textarea>
        <p class="copy-tooltip">üëÜ –ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–¥–µ–ª–∏—Ç—å</p>
        
        <div class="key-fingerprint" id="key-fp" onclick="copyFingerprint()" title="üëÜ –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–ø–µ—á–∞—Ç–∫–∞"></div>
        <p class="copy-tooltip">–û—Ç–ø–µ—á–∞—Ç–æ–∫ –∫–ª—é—á–∞ (SHA-256)</p>
      </div>
      
      <button id="manual-gen" class="action-buttons" style="width: 100%; justify-content: center;">
        üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á–∏
      </button>
    </div>

    <div class="card">
      <h2>üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å</h2>
      <p>Secure Hax –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ:</p>
      <ul style="padding-left: 20px; margin-top: 15px;">
        <li style="margin-bottom: 8px;">–í–∞—à –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á —Ö—Ä–∞–Ω–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ</li>
        <li style="margin-bottom: 8px;">–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏</li>
        <li style="margin-bottom: 8px;">–°–æ–æ–±—â–µ–Ω–∏—è —à–∏—Ñ—Ä—É—é—Ç—Å—è –≤–∞—à–∏–º –ø—É–±–ª–∏—á–Ω—ã–º –∫–ª—é—á–æ–º</li>
        <li>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –≤–∞—à–∏–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–º –∫–ª—é—á–æ–º</li>
      </ul>
    </div>

    <div class="card">
      <h2>‚ö†Ô∏è –í–∞–∂–Ω–æ</h2>
      <p>‚ö†Ô∏è –ü—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –≤–∫–ª–∞–¥–∫–∏ –≤—Å–µ –∫–ª—é—á–∏ –∏ —Å–æ–æ–±—â–µ–Ω–∏—è —É–¥–∞–ª—è—é—Ç—Å—è –±–µ–∑–≤–æ–∑–≤—Ä–∞—Ç–Ω–æ!</p>
      <p style="margin-top: 10px;">üí° –î–ª—è –Ω–æ–≤–æ–≥–æ —Å–µ–∞–Ω—Å–∞ –ø—Ä–æ—Å—Ç–æ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—É—é –∫–æ–º–Ω–∞—Ç—É ‚Äî –Ω–æ–≤—ã–µ –∫–ª—é—á–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</p>
    </div>
  </div>
</div>

<!-- Game Modal -->
<div id="game-modal" class="game-modal">
  <div class="game-content">
    <div class="game-header">
      <h3>üéÆ –ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞</h3>
      <button class="close-game" id="close-game-btn">‚úï</button>
    </div>
    <div class="game-body">
      <div class="game-status" id="game-status">
        –ò–≥—Ä–∞ –Ω–∞—á–Ω—ë—Ç—Å—è, –∫–æ–≥–¥–∞ –æ–±–∞ –∏–≥—Ä–æ–∫–∞ —Å–¥–µ–ª–∞—é—Ç –≤—ã–±–æ—Ä
      </div>
      
      <div class="round-info">
        –†–∞—É–Ω–¥: <span id="current-round">1</span>/3
      </div>
      
      <div class="score-info">
        <span id="my-score">–í–∞—à —Å—á—ë—Ç: 0</span> | 
        <span id="opponent-score">–°—á—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: 0</span>
      </div>
      
      <div class="game-choices" id="game-choices" style="display: none;">
        <button class="choice-btn" data-choice="rock">
          <span class="emoji">‚úä</span>
          –ö–∞–º–µ–Ω—å
        </button>
        <button class="choice-btn" data-choice="paper">
          <span class="emoji">‚úã</span>
          –ë—É–º–∞–≥–∞
        </button>
        <button class="choice-btn" data-choice="scissors">
          <span class="emoji">‚úåÔ∏è</span>
          –ù–æ–∂–Ω–∏—Ü—ã
        </button>
      </div>
      
      <div class="game-timer" id="game-timer" style="display: none;">
        10
      </div>
      
      <div id="game-buttons">
      </div>
    </div>
  </div>
</div>

<!-- Call Modal -->
<div id="call-modal" class="call-modal">
  <div class="call-content">
    <div class="call-status" id="call-status">
      –ó–≤–æ–Ω–æ–∫...
    </div>
    <div class="call-timer" id="call-timer">
      00:00
    </div>
    <div class="call-buttons" id="call-buttons">
    </div>
  </div>
</div>

<!-- SOCKS MODE MESSAGE -->
<div id="socks-message">
  üß¶ SOCKS MODE üß¶
</div>

<!-- CONFETTI CONTAINER -->
<div id="confetti-container"></div>

<!-- TOAST CONTAINER -->
<div id="toast-container"></div>

<!-- SANS EASTER EGG -->
<div style="text-align: center; margin: 30px 0; padding-bottom: calc(30px + env(safe-area-inset-bottom, 0px));">
  <div id="sans-container">
    <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üëª</text></svg>" 
         alt="Sans" 
         id="sans-image"
         width="50"
         height="50"
         onclick="handleSansClick()">
    <div id="sans-counter">0</div>
  </div>
</div>

<footer>
  <div class="footer-content">
    <div class="footer-links">
      <a href="https://t.me/bluzn" target="_blank">‚úàÔ∏è Telegram</a>
      <a href="https://github.com/0xMewhx/SecureHxMessenger" target="_blank">üíª GitHub</a>
      <button id="theme-toggle" title="üåô –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É">üåô</button>
    </div>
    <p class="footer-message" style="margin-top: 15px; opacity: 0.7; font-style: italic;">
      –ï—Å–ª–∏ –¥–æ—á–∏—Ç–∞–ª–∏ –¥–æ —Å—é–¥–∞ ‚Äî –≤—ã –ª–∏–±–æ –º–æ–π –¥—Ä—É–≥, –ª–∏–±–æ –ø–∞—Ä–∞–Ω–æ–∏–∫. –í –ª—é–±–æ–º —Å–ª—É—á–∞–µ, —É–≤–∞–∂–∞—é. üîê
    </p>
    <p class="footer-copyright">
      ¬© 2025 Secure Hax Inc. | Made with üíú by <a href="https://t.me/bluzn" style="display: inline;">–ë–ª—é–∑</a>
    </p>
  </div>
</footer>

<script type="module">
// ============ CONFIG & FIREBASE ============
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
import { getDatabase, ref, set, onValue, push, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyC2J3bVJ5g0hRkVrLsZds7sT7k0",
  authDomain: "secure-hax-messenger.firebaseapp.com",
  databaseURL: "https://secure-hax-messenger-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "secure-hax-messenger",
  storageBucket: "secure-hax-messenger.appspot.com",
  messagingSenderId: "1254007090",
  appId: "1:1254007090:web:3e8c6a8e0f2d9e0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ============ TWEETNACL CRYPTO ============
import nacl from "https://cdnjs.cloudflare.com/ajax/libs/tweetnacl/1.0.3/nacl.min.js";
import sha256 from "https://cdn.jsdelivr.net/npm/js-sha256@0.9.0/build/sha256.min.js";

// ============ STATE ============
const state = {
  userId: generateUserId(),
  roomId: null,
  isHost: false,
  myKeyPair: null,
  peerPublicKey: null,
  activePage: 'home',
  isMobile: false,
  gameState: {
    active: false,
    round: 1,
    myScore: 0,
    opponentScore: 0,
    myChoice: null,
    opponentChoice: null,
    isHost: false,
    timer: null,
    timeLeft: 10,
    waitingForChoice: false
  },
  callState: {
    active: false,
    isCaller: false,
    timeElapsed: 0,
    callTimer: null,
    pc: null,
    localStream: null,
    remoteStream: null
  },
  sansClickCount: 0,
  peerOnline: false,
  peerLeft: false
};

// ============ DOM ELEMENTS ============
const menuBtn = document.getElementById('menu-btn');
const navMenu = document.getElementById('nav-menu');
const roomCodeDisplay = document.getElementById('room-code-display');
const createRoomBtn = document.getElementById('create-room-btn');
const joinRoomBtn = document.getElementById('join-room-btn');
const joinRoomInput = document.getElementById('join-room-input');
const chatStatus = document.getElementById('chat-status');
const chatMessages = document.getElementById('chat-messages');
const chatInputArea = document.getElementById('chat-input-area');
const chatInput = document.getElementById('chat-input');
const sendBtn = document.getElementById('send-btn');
const voiceBtn = document.getElementById('voice-btn');
const callBtn = document.getElementById('call-btn');
const typingIndicator = document.getElementById('typing-indicator');
const sansImage = document.getElementById('sans-image');
const sansCounter = document.getElementById('sans-counter');
const toastContainer = document.getElementById('toast-container');

// ============ HELPER FUNCTIONS ============
function generateUserId() {
  return Math.random().toString(36).substring(2, 15);
}

function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = 'HAX-';
  for(let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

async function sha256hex(message) {
  return sha256(message);
}

function checkMobile() {
  const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         (window.innerWidth <= 768 && 'ontouchstart' in window);
  state.isMobile = isMobileDevice;
  
  if (isMobileDevice) {
    document.body.classList.add('mobile-device');
    document.body.classList.remove('desktop-device');
  } else {
    document.body.classList.add('desktop-device');
    document.body.classList.remove('mobile-device');
  }
}

function toggleMenu() {
  navMenu.classList.toggle('active');
}

function showPage(pageName) {
  // Update menu buttons
  document.querySelectorAll('#nav-menu button').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.page === pageName) {
      btn.classList.add('active');
    }
  });
  
  // Hide all pages
  document.querySelectorAll('.page').forEach(page => {
    page.classList.remove('active');
  });
  
  // Show selected page
  const selectedPage = document.getElementById(`${pageName}-page`);
  if (selectedPage) {
    selectedPage.classList.add('active');
    state.activePage = pageName;
  }
  
  // Hide nav menu
  navMenu.classList.remove('active');
}

function showToast(message, duration = 3000) {
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.innerHTML = `
    <span class="toast-icon">üîî</span>
    <span>${message}</span>
    <button class="toast-close" onclick="this.parentElement.remove()">‚úï</button>
  `;
  toastContainer.appendChild(toast);
  
  // Trigger animation
  setTimeout(() => toast.classList.add('show'), 10);
  
  // Auto remove
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 600);
  }, duration);
}

// ============ CRYPTO FUNCTIONS ============
function generateKeyPair() {
  const keyPair = nacl.box.keyPair();
  state.myKeyPair = keyPair;
  const pubKeyBase64 = nacl.util.encodeBase64(keyPair.publicKey);
  return pubKeyBase64;
}

function encryptMessage(text) {
  if (!state.peerPublicKey || !state.myKeyPair) {
    throw new Error('Keys not initialized');
  }
  
  const nonce = nacl.randomBytes(nacl.box.nonceLength);
  const messageUint8 = nacl.util.decodeUTF8(text);
  const encrypted = nacl.box(messageUint8, nonce, state.peerPublicKey, state.myKeyPair.secretKey);
  
  // Combine nonce + ciphertext for storage
  const combined = new Uint8Array(nonce.length + encrypted.length);
  combined.set(nonce);
  combined.set(encrypted, nonce.length);
  
  return nacl.util.encodeBase64(combined);
}

function decryptMessage(encryptedBase64) {
  if (!state.myKeyPair || !state.peerPublicKey) {
    throw new Error('Keys not initialized');
  }
  
  try {
    const combined = nacl.util.decodeBase64(encryptedBase64);
    const nonce = combined.slice(0, nacl.box.nonceLength);
    const ciphertext = combined.slice(nacl.box.nonceLength);
    
    const decrypted = nacl.box.open(ciphertext, nonce, state.peerPublicKey, state.myKeyPair.secretKey);
    
    if (!decrypted) {
      throw new Error('Decryption failed');
    }
    
    return nacl.util.encodeUTF8(decrypted);
  } catch (e) {
    throw new Error('Failed to decrypt message');
  }
}

// ============ PARTICLE SYSTEM ============
const canvas = document.getElementById('particle-canvas');
const ctx = canvas.getContext('2d');
let particles = [];

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function createParticle() {
  return {
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    size: Math.random() * 2 + 1,
    speedX: (Math.random() - 0.5) * 0.5,
    speedY: (Math.random() - 0.5) * 0.5,
    opacity: Math.random() * 0.5 + 0.2
  };
}

function initParticles() {
  particles = [];
  const particleCount = Math.floor((canvas.width * canvas.height) / 15000);
  for (let i = 0; i < particleCount; i++) {
    particles.push(createParticle());
  }
}

function drawParticles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  particles.forEach(particle => {
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
    ctx.fill();
    
    particle.x += particle.speedX;
    particle.y += particle.speedY;
    
    // Bounce off edges
    if (particle.x < 0 || particle.x > canvas.width) particle.speedX *= -1;
    if (particle.y < 0 || particle.y > canvas.height) particle.speedY *= -1;
  });
  
  requestAnimationFrame(drawParticles);
}

// ============ SANS EASTER EGG ============
function handleSansClick() {
  state.sansClickCount++;
  sansCounter.textContent = state.sansClickCount;
  sansCounter.classList.add('show');
  
  if (state.sansClickCount >= 3) {
    activateSocksMode();
    state.sansClickCount = 0;
    sansCounter.classList.remove('show');
    sansCounter.textContent = '0';
  }
}

function activateSocksMode() {
  document.body.classList.toggle('socks-mode');
  const socksMessage = document.getElementById('socks-message');
  socksMessage.classList.add('active');
  
  showToast('üß¶ SOCKS MODE ACTIVATED! üß¶', 3000);
  
  setTimeout(() => {
    socksMessage.classList.remove('active');
  }, 3000);
}

// ============ CONFETTI ============
function createConfetti(count = 100) {
  const container = document.getElementById('confetti-container');
  const colors = ['#ff5aab', '#8a2be2', '#00ff41', '#ffeb3b', '#ff5722', '#00bcd4'];
  
  for (let i = 0; i < count; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.left = Math.random() > 0.5 ? '100%' : '0%';
    confetti.style.top = '50%';
    confetti.style.animation = Math.random() > 0.5 ? 'fall-left 3s forwards' : 'fall-right 3s forwards';
    confetti.style.animationDelay = Math.random() * 0.5 + 's';
    container.appendChild(confetti);
    
    // Remove after animation
    setTimeout(() => confetti.remove(), 3500);
  }
}

// ============ ROOM STATUS ============
function showRoomStatus() {
  const statusEl = document.getElementById('room-status');
  const statusBall = document.getElementById('status-ball');
  const roomNameEl = document.getElementById('status-room-name');
  const participantsEl = document.getElementById('status-participants');
  
  if (state.roomId) {
    roomNameEl.textContent = state.roomId;
    participantsEl.textContent = state.peerOnline ? '2/2' : '1/2';
    
    if (state.peerOnline) {
      statusBall.className = 'room-status-ball online';
    } else {
      statusBall.className = 'room-status-ball offline';
    }
    
    statusEl.classList.add('show');
  } else {
    statusEl.classList.remove('show');
  }
}

// ============ THEME ============
function toggleTheme() {
  document.body.classList.toggle('hacker-theme');
  const isHacker = document.body.classList.contains('hacker-theme');
  document.getElementById('theme-toggle').textContent = isHacker ? 'üíö' : 'üåô';
  localStorage.setItem('hackerTheme', isHacker);
}

function loadTheme() {
  const isHacker = localStorage.getItem('hackerTheme') === 'true';
  if (isHacker) {
    document.body.classList.add('hacker-theme');
    document.getElementById('theme-toggle').textContent = 'üíö';
  }
}

// ============ GAME FUNCTIONS ============
function startGameInvitation() {
  if (!state.roomId) return;
  
  state.gameState.active = true;
  state.gameState.isHost = true;
  
  // Send invitation
  set(ref(db, `rooms/${state.roomId}/game/invitation`), {
    from: state.userId,
    timestamp: Date.now()
  });
  
  showGameModal('–û–∂–∏–¥–∞–µ–º –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...', 'invite');
  showToast('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ! üéÆ');
}

function makeChoice(choice) {
  if (!state.gameState.waitingForChoice) return;
  
  state.gameState.myChoice = choice;
  state.gameState.waitingForChoice = false;
  
  // Disable buttons
  document.querySelectorAll('.choice-btn').forEach(btn => {
    btn.disabled = true;
  });
  
  // Send choice
  set(ref(db, `rooms/${state.roomId}/game/choice/${state.userId}`), {
    choice: choice,
    timestamp: Date.now()
  });
  
  // Update UI
  document.getElementById('game-timer').style.display = 'none';
  document.getElementById('game-choices').style.display = 'none';
  document.getElementById('game-status').textContent = '–í–∞—à –≤—ã–±–æ—Ä –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω! –û–∂–∏–¥–∞–µ–º –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...';
  
  // Clear local timer
  if (state.gameState.timer) {
    clearInterval(state.gameState.timer);
  }
}

function determineWinner(choice1, choice2) {
  if (choice1 === choice2) return 'tie';
  if (
    (choice1 === 'rock' && choice2 === 'scissors') ||
    (choice1 === 'paper' && choice2 === 'rock') ||
    (choice1 === 'scissors' && choice2 === 'paper')
  ) return 'player1';
  return 'player2';
}

function getChoiceName(choice) {
  const names = { rock: '‚úä –ö–∞–º–µ–Ω—å', paper: '‚úã –ë—É–º–∞–≥–∞', scissors: '‚úåÔ∏è –ù–æ–∂–Ω–∏—Ü—ã' };
  return names[choice] || choice;
}

function showGameModal(statusText, mode) {
  const modal = document.getElementById('game-modal');
  const status = document.getElementById('game-status');
  const choices = document.getElementById('game-choices');
  const timer = document.getElementById('game-timer');
  const buttons = document.getElementById('game-buttons');
  
  status.textContent = statusText;
  choices.style.display = 'none';
  timer.style.display = 'none';
  buttons.innerHTML = '';
  modal.classList.add('active');
  
  if (mode === 'invite') {
    buttons.innerHTML = `
      <button class="game-btn" onclick="closeGameModal(); state.gameState.active = false;">–û—Ç–º–µ–Ω–∞</button>
    `;
  } else if (mode === 'accept') {
    buttons.innerHTML = `
      <button class="game-btn" id="accept-game-btn">–ü—Ä–∏–Ω—è—Ç—å</button>
      <button class="game-btn decline" id="decline-game-btn">–û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
    `;
  } else if (mode === 'choices') {
    choices.style.display = 'flex';
    timer.style.display = 'block';
    timer.textContent = '10';
  } else if (mode === 'result') {
    buttons.innerHTML = `
      <button class="game-btn" id="play-again-btn">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
      <button class="game-btn" onclick="closeGameModal(); state.gameState.active = false;">–í—ã–π—Ç–∏</button>
    `;
  }
}

function closeGameModal() {
  const modal = document.getElementById('game-modal');
  modal.classList.remove('active');
  
  if (state.gameState.timer) {
    clearInterval(state.gameState.timer);
  }
}

function startTimer() {
  state.gameState.timeLeft = 10;
  state.gameState.timer = setInterval(() => {
    state.gameState.timeLeft--;
    document.getElementById('game-timer').textContent = state.gameState.timeLeft;
    
    if (state.gameState.timeLeft <= 0) {
      clearInterval(state.gameState.timer);
      // Auto-choose random if time runs out
      const choices = ['rock', 'paper', 'scissors'];
      const randomChoice = choices[Math.floor(Math.random() * 3)];
      makeChoice(randomChoice);
    }
  }, 1000);
}

function updateGameUI() {
  document.getElementById('current-round').textContent = state.gameState.round;
  document.getElementById('my-score').textContent = `–í–∞—à —Å—á—ë—Ç: ${state.gameState.myScore}`;
  document.getElementById('opponent-score').textContent = `–°—á—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: ${state.gameState.opponentScore}`;
}

function handleGameInvitation(fromUser) {
  if (state.gameState.active) return; // Already in a game
  
  state.gameState.active = true;
  state.gameState.isHost = false;
  state.gameState.waitingForAccept = true;
  
  showGameModal(`${fromUser} –ø—Ä–∏–≥–ª–∞—à–∞–µ—Ç –≤–∞—Å —Å—ã–≥—Ä–∞—Ç—å –≤ –ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞!`, 'accept');
  showToast('–ü–æ–ª—É—á–µ–Ω–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –∏–≥—Ä—É! üéÆ');
}

function setupGameListeners() {
  if (!state.roomId) return;
  
  // Listen for game invitations
  onValue(ref(db, `rooms/${state.roomId}/game/invitation`), (snapshot) => {
    if (snapshot.exists() && !state.gameState.active) {
      const invitation = snapshot.val();
      if (invitation.from !== state.userId) {
        handleGameInvitation(invitation.from);
      }
    }
  });
  
  // Listen for game responses
  onValue(ref(db, `rooms/${state.roomId}/game/response`), (snapshot) => {
    if (snapshot.exists()) {
      const response = snapshot.val();
      if (response.from !== state.userId) {
        if (response.accepted) {
          startGame();
        } else {
          closeGameModal();
          state.gameState.active = false;
          showToast('–ò–≥—Ä–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ üòî');
        }
      }
    }
  });
  
  // Listen for game choices
  onValue(ref(db, `rooms/${state.roomId}/game/choice`), (snapshot) => {
    if (snapshot.exists()) {
      const choices = snapshot.val();
      const players = Object.keys(choices);
      
      if (players.length === 2) {
        // Both players have made their choices
        const player1Choice = choices[players[0]].choice;
        const player2Choice = choices[players[1]].choice;
        
        setTimeout(() => {
          processRoundResult(player1Choice, player2Choice);
        }, 1000); // Show choices for 1 second
      }
    }
  });
}

function acceptGame() {
  state.gameState.waitingForAccept = false;
  
  // Send acceptance response
  set(ref(db, `rooms/${state.roomId}/game/response`), {
    from: state.userId,
    accepted: true,
    timestamp: Date.now()
  });
  
  showToast('–ò–≥—Ä–∞ –ø—Ä–∏–Ω—è—Ç–∞! üéâ');
  startGame();
}

function declineGame() {
  // Send decline response
  set(ref(db, `rooms/${state.roomId}/game/response`), {
    from: state.userId,
    accepted: false,
    timestamp: Date.now()
  });
  
  closeGameModal();
  state.gameState.active = false;
}

function startGame() {
  state.gameState.round = 1;
  state.gameState.myScore = 0;
  state.gameState.opponentScore = 0;
  state.gameState.myChoice = null;
  state.gameState.opponentChoice = null;
  
  updateGameUI();
  showGameModal('–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –°–¥–µ–ª–∞–π—Ç–µ –≤–∞—à –≤—ã–±–æ—Ä:', 'choices');
  
  // Enable choices and start timer
  document.querySelectorAll('.choice-btn').forEach(btn => {
    btn.disabled = false;
  });
  
  state.gameState.waitingForChoice = true;
  startTimer();
}

function processRoundResult(choice1, choice2) {
  const player1Choice = state.gameState.isHost ? choice1 : choice2;
  const player2Choice = state.gameState.isHost ? choice2 : choice1;
  
  const winner = determineWinner(player1Choice, player2Choice);
  let resultText = '';
  
  if (winner === 'tie') {
    resultText = `–ù–∏—á—å—è! (${getChoiceName(player1Choice)} = ${getChoiceName(player2Choice)})`;
  } else if (winner === 'player1') {
    state.gameState.myScore++;
    resultText = `–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ —Ä–∞—É–Ω–¥! (${getChoiceName(player1Choice)} –ø–æ–±–µ–∂–¥–∞–µ—Ç ${getChoiceName(player2Choice)})`;
  } else {
    state.gameState.opponentScore++;
    resultText = `–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ —Ä–∞—É–Ω–¥! (${getChoiceName(player2Choice)} –ø–æ–±–µ–∂–¥–∞–µ—Ç ${getChoiceName(player1Choice)})`;
  }
  
  updateGameUI();
  showGameModal(resultText, 'result');
  
  // Clear choices for next round
  set(ref(db, `rooms/${state.roomId}/game/choice`), null);
  
  if (state.gameState.round >= 3) {
    // Game over
    setTimeout(() => {
      endGame();
    }, 2000);
  } else {
    // Next round
    setTimeout(() => {
      nextRound();
    }, 2000);
  }
}

function nextRound() {
  state.gameState.round++;
  state.gameState.myChoice = null;
  state.gameState.opponentChoice = null;
  
  updateGameUI();
  showGameModal(`–†–∞—É–Ω–¥ ${state.gameState.round}! –°–¥–µ–ª–∞–π—Ç–µ –≤–∞—à –≤—ã–±–æ—Ä:`, 'choices');
  
  document.querySelectorAll('.choice-btn').forEach(btn => {
    btn.disabled = false;
  });
  
  state.gameState.waitingForChoice = true;
  startTimer();
}

function endGame() {
  let finalResult = '';
  
  if (state.gameState.myScore > state.gameState.opponentScore) {
    finalResult = `üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –∏–≥—Ä—É (${state.gameState.myScore}:${state.gameState.opponentScore})!`;
    createConfetti(100);
  } else if (state.gameState.myScore < state.gameState.opponentScore) {
    finalResult = `üòî –í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ –∏–≥—Ä—É (${state.gameState.myScore}:${state.gameState.opponentScore}).`;
  } else {
    finalResult = `ü§ù –ù–∏—á—å—è! (${state.gameState.myScore}:${state.gameState.opponentScore})`;
  }
  
  showGameModal(finalResult, 'result');
  showToast('–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
  
  // Clean up game state after some time
  setTimeout(() => {
    closeGameModal();
    state.gameState.active = false;
    set(ref(db, `rooms/${state.roomId}/game`), null);
  }, 5000);
}

function playAgain() {
  if (state.gameState.isHost) {
    // Host starts new game
    startGameInvitation();
  } else {
    // Guest sends new invitation
    startGameInvitation();
  }
}

// Add event listeners for game buttons
document.getElementById('accept-game-btn').addEventListener('click', acceptGame);
document.getElementById('decline-game-btn').addEventListener('click', declineGame);
document.getElementById('play-again-btn').addEventListener('click', playAgain);

createRoomBtn.addEventListener('click', async () => {
  try {
    const roomCode = generateRoomCode();
    state.roomId = roomCode;
    state.isHost = true;
    
    // Generate keys
    const pubKey = generateKeyPair();
    
    // Create room in Firebase
    const roomRef = ref(db, `rooms/${roomCode}`);
    await set(roomRef, {
      created: serverTimestamp(),
      host: {
        userId: state.userId,
        publicKey: pubKey,
        online: true
      },
      sessionStart: Date.now()
    });
    
    // Show room code
    roomCodeDisplay.textContent = roomCode;
    roomCodeDisplay.style.display = 'block';
    roomCodeDisplay.onclick = () => {
      navigator.clipboard.writeText(roomCode);
      showToast('–ö–æ–¥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! üìã');
      createConfetti(20);
    };
    
    chatStatus.textContent = '‚è≥ –û–∂–∏–¥–∞–µ—Ç—Å—è —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫...';
    chatStatus.style.display = 'block';
    showToast('–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞! –ö–æ–¥: ' + roomCode);
    
    // Listen for guest
    onValue(ref(db, `rooms/${roomCode}/guest`), (snapshot) => {
      if(snapshot.exists()) {
        const guest = snapshot.val();
        state.peerPublicKey = nacl.util.decodeBase64(guest.publicKey);
        state.peerOnline = guest.online !== false;
        state.peerLeft = !guest.online;
        
        chatStatus.textContent = state.peerOnline ? 'üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –ß–∞—Ç –Ω–∞—á–∞—Ç!' : 'üî¥ –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –æ—Ñ–ª–∞–π–Ω';
        showToast('–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è! üéâ');
        createConfetti(50);
        showRoomStatus();
        startChat();
        
        // Track guest online status
        onValue(ref(db, `rooms/${roomCode}/guest/online`), (onlineSnapshot) => {
          state.peerOnline = onlineSnapshot.val() !== false;
          state.peerLeft = !state.peerOnline;
          
          if (!state.peerOnline) {
            chatStatus.textContent = 'üî¥ –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –æ—Ñ–ª–∞–π–Ω';
            showToast('–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç', 4000);
            createConfetti(30);
          } else {
            chatStatus.textContent = 'üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –ß–∞—Ç –Ω–∞—á–∞—Ç!';
          }
          showRoomStatus();
        });
      }
    });
    
  } catch(e) {
    console.error(e);
    showToast('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã: ' + e.message);
  }
});

joinRoomBtn.addEventListener('click', async () => {
  const roomCode = joinRoomInput.value.trim().toUpperCase();
  if(!roomCode) {
    showToast('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã!');
    return;
  }
  
  try {
    state.roomId = roomCode;
    state.isHost = false;
    
    // Generate keys
    const pubKey = generateKeyPair();
    
    // Check if room exists
    const roomRef = ref(db, `rooms/${roomCode}`);
    onValue(roomRef, async (snapshot) => {
      if(!snapshot.exists()) {
        showToast('–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!');
        return;
      }
      
      const room = snapshot.val();
      
      // Get host public key
      if(room.host && room.host.publicKey) {
        state.peerPublicKey = nacl.util.decodeBase64(room.host.publicKey);
        state.peerOnline = room.host.online !== false;
        state.peerLeft = !room.host.online;
        
        // Join as guest
        await set(ref(db, `rooms/${roomCode}/guest`), {
          userId: state.userId,
          publicKey: pubKey,
          online: true
        });
        
        chatStatus.textContent = state.peerOnline ? 'üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –ß–∞—Ç –Ω–∞—á–∞—Ç!' : 'üî¥ –•–æ—Å—Ç –æ—Ñ–ª–∞–π–Ω';
        chatStatus.style.display = 'block';
        showToast('–ü–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ! üéâ');
        createConfetti(50);
        showRoomStatus();
        startChat();
        
        // Track host online status
        onValue(ref(db, `rooms/${roomCode}/host/online`), (onlineSnapshot) => {
          state.peerOnline = onlineSnapshot.val() !== false;
          state.peerLeft = !state.peerOnline;
          
          if (!state.peerOnline) {
            chatStatus.textContent = 'üî¥ –•–æ—Å—Ç –æ—Ñ–ª–∞–π–Ω';
            showToast('–•–æ—Å—Ç –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç', 4000);
            createConfetti(30);
          } else {
            chatStatus.textContent = 'üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –ß–∞—Ç –Ω–∞—á–∞—Ç!';
          }
          showRoomStatus();
        });
      }
    }, { onlyOnce: true });
    
  } catch(e) {
    console.error(e);
    showToast('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + e.message);
  }
});

function startChat() {
  roomSetup.style.display = 'none';
  chatMessages.style.display = 'flex';
  chatInputArea.style.display = 'flex';
  
  // Show room status indicator on mobile
  showRoomStatus();
  
  // Set up online status tracking
  setupOnlineStatusTracking();
  
  // Listen for typing indicator
  const typingRef = ref(db, `rooms/${state.roomId}/typing`);
  onValue(typingRef, (snapshot) => {
    if(snapshot.exists()) {
      const typing = snapshot.val();
      // Check if OTHER user is typing
      const otherUserTyping = Object.keys(typing).some(uid => 
        uid !== state.userId && typing[uid] === true
      );
      
      if(otherUserTyping) {
        typingIndicator.classList.add('show');
        chatMessages.scrollTop = chatMessages.scrollHeight;
      } else {
        typingIndicator.classList.remove('show');
      }
    }
  });
  
  // Listen for messages
  const messagesRef = ref(db, `rooms/${state.roomId}/messages`);
  onValue(messagesRef, (snapshot) => {
    // Clear messages but keep typing indicator
    const messages = chatMessages.querySelectorAll('.message');
    messages.forEach(m => m.remove());
    
    if(snapshot.exists()) {
      const messagesList = [];
      snapshot.forEach((child) => {
        messagesList.push({ id: child.key, ...child.val() });
      });
      
      messagesList.sort((a, b) => a.timestamp - b.timestamp);
      
      messagesList.forEach(msg => {
        // Skip messages from unknown senders (old session users)
        if (msg.sender !== state.userId && state.peerPublicKey) {
          try {
            const decrypted = decryptMessage(msg.ciphertext);
            
            // Check for socks mode
            if(decrypted.toLowerCase().includes('socks') || decrypted.toLowerCase().includes('–Ω–æ—Å–∫–∏')) {
              activateSocksMode();
            }
            
            // Check for game command (only from other user)
            if (msg.sender !== state.userId && decrypted.toLowerCase().includes('–∏–≥—Ä–∞—Ç—å')) {
              handleGameInvitation(msg.sender);
            }
            
            displayMessage(decrypted, msg.sender === state.userId);
          } catch(e) {
            // Silently skip messages that can't be decrypted (from old sessions)
          }
        } else if (msg.sender === state.userId) {
          // Always show own messages
          try {
            const decrypted = decryptMessage(msg.ciphertext);
            displayMessage(decrypted, true);
          } catch(e) {
            // Silently skip
          }
        }
      });
    }
    
    chatMessages.scrollTop = chatMessages.scrollHeight;
  });
  
  // Listen for game events
  setupGameListeners();
  
  // Listen for call events
  setupCallListeners();
}

function setupOnlineStatusTracking() {
  if (!state.roomId) return;
  
  const userPath = state.isHost ? 'host' : 'guest';
  
  // Track my own online status
  onDisconnect(ref(db, `rooms/${state.roomId}/${userPath}/online`)).set(false);
  
  // Track peer online status
  const peerPath = state.isHost ? 'guest' : 'host';
  onValue(ref(db, `rooms/${state.roomId}/${peerPath}/online`), (snapshot) => {
    const isOnline = snapshot.val() !== false;
    state.peerOnline = isOnline;
    state.peerLeft = !isOnline;
    
    chatStatus.textContent = isOnline ? 'üü¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –ß–∞—Ç –Ω–∞—á–∞—Ç!' : 'üî¥ –°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –æ—Ñ–ª–∞–π–Ω';
    showRoomStatus();
    
    if (!isOnline) {
      showToast('–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç', 4000);
    }
  });
}

function displayMessage(text, isSent) {
  const msgDiv = document.createElement('div');
  msgDiv.className = 'message ' + (isSent ? 'sent' : 'received');
  
  // Check if voice message
  if (text.startsWith('[VOICE]:')) {
    const base64Audio = text.substring(8); // data:audio/webm;base64,xxxxx
    const playerId = 'voice-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    
    // Create waveform bars (random heights for visual effect)
    const bars = Array.from({length: 25}, () => {
      const height = 8 + Math.random() * 20;
      return `<div class="voice-wave-bar" style="height: ${height}px;"></div>`;
    }).join('');
    
    msgDiv.innerHTML = `
      <div class="voice-player" data-player-id="${playerId}">
        <button class="voice-play-btn" data-action="play">‚ñ∂Ô∏è</button>
        <div class="voice-waveform">${bars}</div>
        <div class="voice-duration">0:00</div>
        <audio data-voice-audio="${playerId}">
          <source src="${base64Audio}" type="audio/webm">
        </audio>
      </div>
      <div class="message-time">${new Date().toLocaleTimeString()}</div>
    `;
    
    // Setup audio controls
    setTimeout(() => setupVoicePlayer(playerId), 0);
  } else {
    msgDiv.innerHTML = `
      <div>${text}</div>
      <div class="message-time">${new Date().toLocaleTimeString()}</div>
    `;
  }
  
  chatMessages.appendChild(msgDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Setup custom voice player controls
function setupVoicePlayer(playerId) {
  const player = document.querySelector(`[data-player-id="${playerId}"]`);
  if (!player) return;
  
  const audio = player.querySelector(`[data-voice-audio="${playerId}"]`);
  const playBtn = player.querySelector('.voice-play-btn');
  const durationEl = player.querySelector('.voice-duration');
  const waveBars = player.querySelectorAll('.voice-wave-bar');
  
  let isPlaying = false;
  let animationFrame = null;
  
  // Format time (seconds to mm:ss)
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };
  
  // Update waveform animation
  const updateWaveform = () => {
    if (!isPlaying || !audio.duration) return;
    
    const progress = audio.currentTime / audio.duration;
    const activeBarCount = Math.floor(waveBars.length * progress);
    
    waveBars.forEach((bar, index) => {
      if (index < activeBarCount) {
        bar.classList.add('active');
      } else {
        bar.classList.remove('active');
      }
    });
    
    if (isPlaying) {
      animationFrame = requestAnimationFrame(updateWaveform);
    }
  };
  
  // Play/Pause toggle
  playBtn.addEventListener('click', () => {
    if (isPlaying) {
      audio.pause();
      playBtn.textContent = '‚ñ∂Ô∏è';
      isPlaying = false;
      if (animationFrame) cancelAnimationFrame(animationFrame);
    } else {
      // Pause all other audio players
      document.querySelectorAll('[data-voice-audio]').forEach(otherAudio => {
        if (otherAudio !== audio && !otherAudio.paused) {
          otherAudio.pause();
          const otherPlayer = otherAudio.closest('.voice-player');
          if (otherPlayer) {
            otherPlayer.querySelector('.voice-play-btn').textContent = '‚ñ∂Ô∏è';
            otherPlayer.querySelectorAll('.voice-wave-bar').forEach(bar => bar.classList.remove('active'));
          }
        }
      });
      
      audio.play();
      playBtn.textContent = '‚è∏Ô∏è';
      isPlaying = true;
      updateWaveform();
    }
  });
  
  // Update duration display
  audio.addEventListener('loadedmetadata', () => {
    durationEl.textContent = formatTime(audio.duration);
  });
  
  audio.addEventListener('timeupdate', () => {
    durationEl.textContent = formatTime(audio.currentTime);
  });
  
  // Reset on end
  audio.addEventListener('ended', () => {
    playBtn.textContent = '‚ñ∂Ô∏è';
    isPlaying = false;
    waveBars.forEach(bar => bar.classList.remove('active'));
    durationEl.textContent = formatTime(audio.duration);
    if (animationFrame) cancelAnimationFrame(animationFrame);
  });
  
  // Prevent context menu (right-click download)
  audio.addEventListener('contextmenu', (e) => e.preventDefault());
}

sendBtn.addEventListener('click', sendMessage);
chatInput.addEventListener('keydown', (e) => {
  if(e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

async function sendMessage() {
  const text = chatInput.value.trim();
  if(!text) return;
  
  try {
    // Clear typing indicator immediately
    await set(ref(db, `rooms/${state.roomId}/typing/${state.userId}`), false);
    
    const encrypted = encryptMessage(text);
    
    const messageRef = push(ref(db, `rooms/${state.roomId}/messages`));
    await set(messageRef, {
      sender: state.userId,
      ciphertext: encrypted,
      timestamp: serverTimestamp()
    });
    
    chatInput.value = '';
  } catch(e) {
    console.error(e);
    showToast('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ' + e.message);
  }
}

// ============ CALL SYSTEM ============

callBtn.addEventListener('click', () => {
  if (!state.peerOnline) {
    showToast('–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –æ—Ñ—Ñ–ª–∞–π–Ω!');
    return;
  }
  if (state.callState.active) {
    showToast('–ó–≤–æ–Ω–æ–∫ —É–∂–µ –∏–¥—ë—Ç!');
    return;
  }
  
  initiateCall();
});

function initiateCall() {
  state.callState.active = true;
  state.callState.isCaller = true;
  showCallModal('–ó–≤–æ–Ω–æ–∫...', 'calling');
  
  // Send call request
  set(ref(db, `rooms/${state.roomId}/call/request`), {
    from: state.userId,
    timestamp: Date.now()
  });
  
  setupCallPeerConnection();
  createOffer();
}

function showCallModal(statusText, mode) {
  const modal = document.getElementById('call-modal');
  const status = document.getElementById('call-status');
  const timer = document.getElementById('call-timer');
  const buttons = document.getElementById('call-buttons');
  
  status.textContent = statusText;
  timer.textContent = '00:00';
  buttons.innerHTML = '';
  modal.classList.add('active');
  
  if (mode === 'incoming') {
    buttons.innerHTML = `
      <button class="call-btn accept" onclick="acceptCall()">‚úÖ</button>
      <button class="call-btn decline" onclick="declineCall()">‚ùå</button>
    `;
  } else if (mode === 'ongoing' || mode === 'calling') {
    buttons.innerHTML = `
      <button class="call-btn end" onclick="endCall()">‚ùå</button>
    `;
  }
  
  startCallTimer();
}

function startCallTimer() {
  state.callState.timeElapsed = 0;
  const timerEl = document.getElementById('call-timer');
  
  state.callState.callTimer = setInterval(() => {
    state.callState.timeElapsed++;
    const mins = Math.floor(state.callState.timeElapsed / 60).toString().padStart(2, '0');
    const secs = (state.callState.timeElapsed % 60).toString().padStart(2, '0');
    timerEl.textContent = `${mins}:${secs}`;
  }, 1000);
}

function closeCallModal() {
  const modal = document.getElementById('call-modal');
  modal.classList.remove('active');
  
  if (state.callState.callTimer) {
    clearInterval(state.callState.callTimer);
  }
}

function setupCallListeners() {
  // Listen for incoming call requests
  onValue(ref(db, `rooms/${state.roomId}/call/request`), (snapshot) => {
    if (snapshot.exists() && !state.callState.active) {
      const request = snapshot.val();
      if (request.from !== state.userId) {
        state.callState.active = true;
        state.callState.isCaller = false;
        showCallModal('–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫', 'incoming');
        setupCallPeerConnection();
      }
    }
  });
  
  // Listen for call responses
  onValue(ref(db, `rooms/${state.roomId}/call/response`), (snapshot) => {
    if (snapshot.exists()) {
      const response = snapshot.val();
      if (response.from !== state.userId) {
        if (response.accepted) {
          // Call accepted
          showCallModal('–ó–≤–æ–Ω–æ–∫ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ', 'ongoing');
        } else {
          // Call declined
          endCall();
          showToast('–ó–≤–æ–Ω–æ–∫ –æ—Ç–∫–ª–æ–Ω—ë–Ω');
        }
      }
    }
  });
  
  // Listen for WebRTC signaling
  onValue(ref(db, `rooms/${state.roomId}/call/offer`), (snapshot) => {
    if (snapshot.exists() && !state.callState.isCaller) {
      const offer = snapshot.val();
      state.callState.pc.setRemoteDescription(new RTCSessionDescription(offer));
      createAnswer();
    }
  });
  
  onValue(ref(db, `rooms/${state.roomId}/call/answer`), (snapshot) => {
    if (snapshot.exists() && state.callState.isCaller) {
      const answer = snapshot.val();
      state.callState.pc.setRemoteDescription(new RTCSessionDescription(answer));
    }
  });
  
  onValue(ref(db, `rooms/${state.roomId}/call/candidate`), (snapshot) => {
    if (snapshot.exists()) {
      const candidate = snapshot.val();
      if (candidate.candidate) {  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ candidate
        state.callState.pc.addIceCandidate(new RTCIceCandidate(candidate));
      }
    }
  });
  
  // Listen for call end
  onValue(ref(db, `rooms/${state.roomId}/call/end`), (snapshot) => {
    if (snapshot.exists()) {
      endCall();
      showToast('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω');
    }
  });
}

function setupCallPeerConnection() {
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun.stunprotocol.org:3478' }
    ]
  });
  
  state.callState.pc = pc;
  
  // Get local audio stream
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
      state.callState.localStream = stream;
      stream.getTracks().forEach(track => pc.addTrack(track, stream));
    })
    .catch(err => {
      console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:', err);
      showToast('–û—à–∏–±–∫–∞: –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É');
      endCall();
    });
  
  pc.ontrack = (event) => {
    if (!state.callState.remoteStream) {
      state.callState.remoteStream = new MediaStream();
    }
    state.callState.remoteStream.addTrack(event.track);
    
    // Auto-play remote audio
    const audio = new Audio();
    audio.srcObject = state.callState.remoteStream;
    audio.play().catch(err => console.error('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ:', err));
  };
  
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      set(ref(db, `rooms/${state.roomId}/call/candidate`), {
        candidate: event.candidate.candidate,
        sdpMid: event.candidate.sdpMid,
        sdpMLineIndex: event.candidate.sdpMLineIndex
      });
    }
  };
  
  pc.oniceconnectionstatechange = () => {
    if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
      endCall();
    }
  };
}

function createOffer() {
  state.callState.pc.createOffer()
    .then(offer => {
      state.callState.pc.setLocalDescription(offer);
      set(ref(db, `rooms/${state.roomId}/call/offer`), offer);
    })
    .catch(err => console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è offer:', err));
}

function createAnswer() {
  state.callState.pc.createAnswer()
    .then(answer => {
      state.callState.pc.setLocalDescription(answer);
      set(ref(db, `rooms/${state.roomId}/call/answer`), answer);
    })
    .catch(err => console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è answer:', err));
}

function acceptCall() {
  // Send acceptance
  set(ref(db, `rooms/${state.roomId}/call/response`), {
    from: state.userId,
    accepted: true,
    timestamp: Date.now()
  });
  
  showCallModal('–ó–≤–æ–Ω–æ–∫ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ', 'ongoing');
}

function declineCall() {
  // Send decline
  set(ref(db, `rooms/${state.roomId}/call/response`), {
    from: state.userId,
    accepted: false,
    timestamp: Date.now()
  });
  
  endCall();
}

function endCall() {
  if (state.callState.pc) {
    state.callState.pc.close();
    state.callState.pc = null;
  }
  
  if (state.callState.localStream) {
    state.callState.localStream.getTracks().forEach(track => track.stop());
    state.callState.localStream = null;
  }
  
  state.callState.remoteStream = null;
  state.callState.active = false;
  state.callState.isCaller = false;
  
  closeCallModal();
  
  // Clear call data in Firebase
  set(ref(db, `rooms/${state.roomId}/call`), null);
  
  // Send end signal
  set(ref(db, `rooms/${state.roomId}/call/end`), {
    from: state.userId,
    timestamp: Date.now()
  });
}

// ============ MANUAL KEY GEN ============
document.getElementById('manual-gen').addEventListener('click', () => {
  const pubKey = generateKeyPair();
  document.getElementById('pub-key-display').value = pubKey;
  document.getElementById('key-info').style.display = 'block';
  sha256hex(state.myKeyPair.publicKey).then(fp => {
    document.getElementById('key-fp').textContent = fp.slice(0, 32);
  });
  showToast('–ö–ª—é—á–∏ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã! üîë');
  createConfetti(30);
});

// ============ PWA –∏ MOBILE –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò ============

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Service Worker –¥–ª—è PWA —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
async function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/'
      });
      
      console.log('‚úÖ Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω:', registration.scope);
      
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Service Worker
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('üîÑ –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è Service Worker –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...');
        
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            console.log('üöÄ –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞!');
            showToast('üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ! –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.', 5000);
          }
        });
      });
      
      // –ü—Ä–æ—Å–ª—É—à–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç Service Worker
      navigator.serviceWorker.addEventListener('message', event => {
        console.log('üì® –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç SW:', event.data);
      });
      
    } catch (error) {
      console.log('‚ùå –û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ Service Worker:', error);
    }
  } else {
    console.log('‚ùå Service Worker –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
  }
}

// –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
function setupKeyboardOptimization() {
  const chatInput = document.getElementById('chat-input');
  
  if (!chatInput) return;
  
  // –§–æ–∫—É—Å –Ω–∞ input - —Å–¥–≤–∏–≥–∞–µ–º viewport
  chatInput.addEventListener('focus', () => {
    setTimeout(() => {
      chatInput.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
        inline: 'nearest'
      });
    }, 300); // –î–∞–µ–º –≤—Ä–µ–º—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ –ø–æ—è–≤–∏—Ç—å—Å—è
  });
  
  // –ü—Ä–∏ —Ñ–æ–∫—É—Å–µ –¥–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö)
  chatInput.addEventListener('focus', () => {
    if (state.isMobile) {
      document.body.classList.add('keyboard-open');
      document.documentElement.style.setProperty('--keyboard-height', '300px');
    }
  });
  
  // –ü—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Ñ–æ–∫—É—Å–∞ —É–±–∏—Ä–∞–µ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é (—Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö)
  chatInput.addEventListener('blur', () => {
    if (state.isMobile) {
      document.body.classList.remove('keyboard-open');
      document.documentElement.style.setProperty('--keyboard-height', '0px');
    }
  });
  
  // –û—Ç–∫–ª—é—á–∞–µ–º zoom –Ω–∞ focus –¥–ª—è iOS
  chatInput.addEventListener('touchstart', () => {
    document.body.style.zoom = '1';
    setTimeout(() => {
      document.body.style.zoom = '';
    }, 500);
  });
}

// –£–ª—É—á—à–µ–Ω–∏—è –¥–ª—è touch —É—Å—Ç—Ä–æ–π—Å—Ç–≤
function setupTouchOptimizations() {
  // –û—Ç–∫–ª—é—á–∞–µ–º context menu –Ω–∞ long press
  document.addEventListener('contextmenu', (e) => {
    if (state.isMobile) {
      e.preventDefault();
    }
  });
  
  // Touch feedback –¥–ª—è –∫–Ω–æ–ø–æ–∫
  document.addEventListener('touchstart', (e) => {
    const target = e.target.closest('button, .btn, [role="button"]');
    if (target) {
      target.classList.add('touch-active');
    }
  }, { passive: true });
  
  document.addEventListener('touchend', (e) => {
    const target = e.target.closest('button, .btn, [role="button"]');
    if (target) {
      setTimeout(() => {
        target.classList.remove('touch-active');
      }, 150);
    }
  }, { passive: true });
  
  // –û—Ç–∫–ª—é—á–∞–µ–º pull-to-refresh –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
  if (state.isMobile) {
    let startY = 0;
    document.addEventListener('touchstart', (e) => {
      startY = e.touches[0].clientY;
    });
    
    document.addEventListener('touchmove', (e) => {
      const currentY = e.touches[0].clientY;
      const scrollTop = window.pageYOffset;
      
      // –û—Ç–∫–ª—é—á–∞–µ–º pull-to-refresh —Ç–æ–ª—å–∫–æ –≤ —á–∞—Ç–µ
      if (scrollTop <= 0 && currentY > startY && state.activePage === 'chat') {
        e.preventDefault();
      }
    });
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
function setupOrientationHandler() {
  window.addEventListener('orientationchange', () => {
    setTimeout(() => {
      checkMobile();
      // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—ã—Å–æ—Ç—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤
      const chatMessages = document.getElementById('chat-messages');
      if (chatMessages && state.activePage === 'chat') {
        chatMessages.style.maxHeight = window.innerHeight * 0.5 + 'px';
      }
    }, 500); // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ —Å–º–µ–Ω—É –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
  });
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è accidental zoom
function setupZoomPrevention() {
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (event) => {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, false);
}

// ============ INIT ============
document.addEventListener('DOMContentLoaded', function() {
  console.log('Secure Hax Messenger initialized! üí¨üîê');
  
  // Menu button handler
  menuBtn.addEventListener('click', toggleMenu);
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
  checkMobile();
  console.log('Mobile mode:', state.isMobile ? 'ON' : 'OFF');
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
  resizeCanvas();
  initParticles();
  drawParticles();
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Å–∞–π–∑–∞
  window.addEventListener('resize', () => {
    resizeCanvas();
    initParticles();
  });
  
  // PWA –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
  registerServiceWorker();
  
  // Mobile –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
  setupKeyboardOptimization();
  setupTouchOptimizations();
  setupOrientationHandler();
  setupZoomPrevention();
  
  showPage('home');
  checkMobile();
  loadTheme(); // Load saved theme
  
  // ============ SCROLL REVEAL ANIMATIONS ============
  // Intersection Observer –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  const observerOptions = {
    threshold: 0.1,
    rootMargin: '0px 0px -50px 0px'
  };
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('revealed');
        observer.unobserve(entry.target); // –ê–Ω–∏–º–∞—Ü–∏—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
      }
    });
  }, observerOptions);
  
  // –ù–∞–±–ª—é–¥–∞–µ–º –∑–∞ –≤—Å–µ–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ —Å –∫–ª–∞—Å—Å–æ–º scroll-reveal
  document.querySelectorAll('.scroll-reveal, .scroll-reveal-left, .scroll-reveal-right, .scroll-reveal-scale').forEach(el => {
    observer.observe(el);
  });
  
  // Setup game button listeners
  document.getElementById('close-game-btn').addEventListener('click', closeGameModal);
  
  document.querySelectorAll('.choice-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const choice = this.getAttribute('data-choice');
      makeChoice(choice);
    });
  });
  
  // Theme toggle
  document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
  
  // Page visibility –∏ –º–æ–±–∏–ª—å–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
  document.addEventListener('visibilitychange', () => {
    checkMobile();
    if (document.visibilityState === 'visible') {
      setTimeout(checkMobile, 100);
    }
  });

  // PWA –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('üì± PWA –º–æ–∂–µ—Ç –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');
    e.preventDefault();
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –ø–æ–∑–¥–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    window.deferredPrompt = e;
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫–∏
    showToast('üì± –ù–∞–∂–º–∏—Ç–µ "–î–æ–±–∞–≤–∏—Ç—å –Ω–∞ –≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω" –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è!', 5000);
  });

  window.addEventListener('appinstalled', (e) => {
    console.log('‚úÖ PWA —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ');
    showToast('üéâ Secure Hax Messenger —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–∞–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ!');
  });

  window.addEventListener('beforeunload', () => {
    if (state.roomId) {
      const userPath = state.isHost ? 'host' : 'guest';
      set(ref(db, `rooms/${state.roomId}/${userPath}/online`), false);
    }
    if (state.callState.active) {
      endCall();
    }
  });

  // Touch gesture –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ UX
  let touchStartY = 0;
  let touchStartX = 0;
  
  document.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
    touchStartX = e.touches[0].clientX;
  }, { passive: true });
  
  document.addEventListener('touchend', (e) => {
    const touchEndY = e.changedTouches[0].clientY;
    const touchEndX = e.changedTouches[0].clientX;
    const deltaY = touchEndY - touchStartY;
    const deltaX = touchEndX - touchStartX;
    
    // Detected swipe gestures –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
    if (Math.abs(deltaY) < 50 && Math.abs(deltaX) > 100) {
      if (deltaX > 50 && state.activePage === 'chat') {
        // Swipe right - –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é
        toggleMenu();
      }
    }
  }, { passive: true });

  // –î–æ–±–∞–≤–ª—è–µ–º CSS –∫–ª–∞—Å—Å—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è touch –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
  const isTouchCapable = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (isTouchCapable) {
    document.body.classList.add('touch-capable');
  } else {
    document.body.classList.add('no-touch');
  }

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
  const setCSSVariables = () => {
    const root = document.documentElement;
    
    // Safe area –∑–Ω–∞—á–µ–Ω–∏—è
    root.style.setProperty('--safe-area-inset-bottom', 
      getComputedStyle(document.body).getPropertyValue('padding-bottom'));
    
    // –í–∏—Å–æ—Ç–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
    root.style.setProperty('--keyboard-height', '0px');
  };

  setCSSVariables();
  window.addEventListener('resize', setCSSVariables);
});
</script>
</body>
</html>
