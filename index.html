<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure Chat</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #2a003f, #0f001a);
      color: #fff;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    h1 { margin: 20px 0; }
    .card {
      background: rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 20px;
      margin: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      backdrop-filter: blur(10px);
    }
    button {
      background: #6c2b8f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      margin: 6px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
      transition: transform 0.2s, background 0.2s;
    }
    button:hover { transform: scale(1.05); background: #8e3ec6; }
    input, textarea {
      width: 90%;
      margin: 8px 0;
      padding: 10px;
      border-radius: 10px;
      border: none;
      outline: none;
    }
    textarea { height: 80px; }
    /* Toast */
    #toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #333;
      color: #fff;
      padding: 12px 20px;
      border-radius: 10px;
      opacity: 0;
      transition: opacity 0.5s, transform 0.5s;
      transform: translateY(-20px);
      z-index: 1000;
    }
    #toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    /* Footer Telegram */
    footer {
      width:100%; 
      text-align:center; 
      margin:24px 0;
    }
    footer img {
      width:32px; 
      height:32px; 
      transition: transform 0.2s;
      cursor: pointer;
    }
    footer img:hover { transform: scale(1.2); }
  </style>
</head>
<body>
  <h1>üîê Secure Chat</h1>

  <div class="card">
    <h2>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏</h2>
    <button id="gen">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—É –∫–ª—é—á–µ–π</button>
    
    <!-- —Å—Ç—Ä–µ–ª–∫–∞ –¥–ª—è –∞–∫–∫–æ—Ä–¥–µ–æ–Ω–∞ -->
    <div style="text-align:center; margin-top:8px;">
      <span id="toggleKeys" style="cursor:pointer; font-size:20px; user-select:none;">‚ñº</span>
    </div>

    <!-- —Å–∫—Ä—ã—Ç—ã–π –±–ª–æ–∫ -->
    <div id="advancedKeys" style="max-height:0; overflow:hidden; transition:max-height 0.4s ease, padding 0.3s ease;">
      <div style="margin-top:12px;">
        <input type="text" id="importPriv" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á">
        <button id="importPrivBtn">–ò–º–ø–æ—Ä—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞</button>
      </div>
      <div style="margin-top:12px;">
        <button id="savePrivBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á (–ø–∞—Ä–æ–ª—å)</button>
        <button id="loadPrivBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á (–ø–∞—Ä–æ–ª—å)</button>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞</h2>
    <input type="text" id="peerPub" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á">
    <button id="importPeer">–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á</button>
    <p>–û—Ç–ø–µ—á–∞—Ç–æ–∫: <span id="peerFp">-</span></p>
    <button id="clearPeer">–û—á–∏—Å—Ç–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π –∫–ª—é—á</button>
  </div>

  <div class="card">
    <h2>–°–æ–æ–±—â–µ–Ω–∏—è</h2>
    <textarea id="plain" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..."></textarea><br>
    <button id="encrypt">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
    <textarea id="cipher" placeholder="–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç..."></textarea><br>
    <button id="decrypt">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
  </div>

  <div id="toast"></div>

  <footer>
    <a href="https://t.me/BluzikArhimew" target="_blank">
      <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/telegram.svg" alt="Telegram">
    </a>
  </footer>

  <script>
    // --- —É—Ç–∏–ª–∏—Ç—ã ---
    const toBase64 = arr => btoa(String.fromCharCode(...new Uint8Array(arr)));
    const fromBase64 = str => new Uint8Array(atob(str).split("").map(c => c.charCodeAt(0)));
    const showToast = msg => {
      const toast = document.getElementById('toast');
      toast.textContent = msg;
      toast.className = 'show';
      setTimeout(() => toast.className = toast.className.replace('show',''), 3000);
    };
    const sanitize = str => str.replace(/[&<>"']/g, c => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));

    // --- –∫–ª—é—á–∏ ---
    let privKey, pubKey, peerPub;

    async function generateKeyPair() {
      const keyPair = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, true, ['deriveKey']);
      privKey = keyPair.privateKey;
      pubKey = keyPair.publicKey;
      const raw = await crypto.subtle.exportKey('raw', pubKey);
      const b64 = toBase64(raw);
      prompt('–í–∞—à –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á (–æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É):', b64);
    }

    // –∞–∫–∫–æ—Ä–¥–µ–æ–Ω
    const toggleKeys = document.getElementById('toggleKeys');
    const advancedKeys = document.getElementById('advancedKeys');
    let keysOpen = false;
    toggleKeys.addEventListener('click', () => {
      keysOpen = !keysOpen;
      if (keysOpen) {
        advancedKeys.style.maxHeight = "500px";
        advancedKeys.style.padding = "10px 0";
        toggleKeys.textContent = "‚ñ≤";
      } else {
        advancedKeys.style.maxHeight = "0";
        advancedKeys.style.padding = "0";
        toggleKeys.textContent = "‚ñº";
      }
    });

    // --- –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ ---
    async function sha256hex(buf) {
      const hash = await crypto.subtle.digest('SHA-256', buf);
      return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    document.getElementById('importPeer').onclick = async () => {
      const s = document.getElementById('peerPub').value.trim();
      if (!s) { showToast('–í—Å—Ç–∞–≤—å—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á'); return; }
      try {
        const raw = fromBase64(s);
        peerPub = raw;
        localStorage.setItem('peerPub', s);
        document.getElementById('peerFp').textContent = await sha256hex(raw);
        showToast('–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
        document.getElementById('peerPub').value = '';
      } catch { showToast('–ù–µ–≤–µ—Ä–Ω—ã–π –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á'); }
    };

    // –∑–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞
    (async () => {
      const saved = localStorage.getItem('peerPub');
      if (saved) {
        peerPub = fromBase64(saved);
        document.getElementById('peerFp').textContent = await sha256hex(peerPub);
      }
    })();

    document.getElementById('clearPeer').onclick = () => {
      localStorage.removeItem('peerPub');
      peerPub = null;
      document.getElementById('peerFp').textContent = '-';
      showToast('–ö–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –æ—á–∏—â–µ–Ω');
    };

    // --- —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ ---
    async function deriveSecret() {
      const peerKey = await crypto.subtle.importKey('raw', peerPub, {name:'ECDH', namedCurve:'P-256'}, true, []);
      return crypto.subtle.deriveKey({name:'ECDH', public:peerKey}, privKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
    }

    document.getElementById('encrypt').onclick = async () => {
      if (!privKey || !peerPub) return showToast('–ù–µ—Ç –∫–ª—é—á–µ–π');
      const msg = sanitize(document.getElementById('plain').value);
      if (!msg) return;
      const key = await deriveSecret();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, new TextEncoder().encode(msg));
      document.getElementById('cipher').value = toBase64(iv) + ':' + toBase64(enc);
      document.getElementById('plain').value = '';
      showToast('–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ');
    };

    document.getElementById('decrypt').onclick = async () => {
      if (!privKey || !peerPub) return showToast('–ù–µ—Ç –∫–ª—é—á–µ–π');
      const val = document.getElementById('cipher').value.trim();
      if (!val.includes(':')) return showToast('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç');
      const [ivB64, dataB64] = val.split(':');
      const key = await deriveSecret();
      try {
        const dec = await crypto.subtle.decrypt({name:'AES-GCM', iv:fromBase64(ivB64)}, key, fromBase64(dataB64));
        document.getElementById('plain').value = new TextDecoder().decode(dec);
        document.getElementById('cipher').value = '';
        showToast('–°–æ–æ–±—â–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ');
      } catch { showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ'); }
    };

    // --- –∫–Ω–æ–ø–∫–∏ ---
    document.getElementById('gen').onclick = generateKeyPair;
    document.getElementById('importPrivBtn').onclick = async () => {
      try {
        const val = document.getElementById('importPriv').value.trim();
        if (!val) return showToast('–í—Å—Ç–∞–≤—å—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á');
        const raw = fromBase64(val);
        privKey = await crypto.subtle.importKey('pkcs8', raw, {name:'ECDH', namedCurve:'P-256'}, true, ['deriveKey']);
        showToast('–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω');
        document.getElementById('importPriv').value = '';
      } catch { showToast('–ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á'); }
    };

    // —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ/–∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ —á–µ—Ä–µ–∑ –ø–∞—Ä–æ–ª—å
    async function savePriv() {
      if (!privKey) return showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á');
      const pw = prompt('–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞:');
      if (!pw) return;
      const raw = await crypto.subtle.exportKey('pkcs8', privKey);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const key = await crypto.subtle.importKey('raw', new TextEncoder().encode(pw), 'PBKDF2', false, ['deriveKey']);
      const aes = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations:100000, hash:'SHA-256'}, key, {name:'AES-GCM', length:256}, false, ['encrypt']);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = await crypto.subtle.encrypt({name:'AES-GCM', iv}, aes, raw);
      localStorage.setItem('privEnc', JSON.stringify({salt:toBase64(salt), iv:toBase64(iv), data:toBase64(enc)}));
      showToast('–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
    }

    async function loadPriv() {
      const data = localStorage.getItem('privEnc');
      if (!data) return showToast('–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞');
      const pw = prompt('–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞:');
      if (!pw) return;
      try {
        const obj = JSON.parse(data);
        const salt = fromBase64(obj.salt);
        const iv = fromBase64(obj.iv);
        const enc = fromBase64(obj.data);
        const key = await crypto.subtle.importKey('raw', new TextEncoder().encode(pw), 'PBKDF2', false, ['deriveKey']);
        const aes = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations:100000, hash:'SHA-256'}, key, {name:'AES-GCM', length:256}, false, ['decrypt']);
        const raw = await crypto.subtle.decrypt({name:'AES-GCM', iv}, aes, enc);
        privKey = await crypto.subtle.importKey('pkcs8', raw, {name:'ECDH', namedCurve:'P-256'}, true, ['deriveKey']);
        showToast('–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –∑–∞–≥—Ä—É–∂–µ–Ω');
      } catch { showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞'); }
    }

    document.getElementById('savePrivBtn').onclick = savePriv;
    document.getElementById('loadPrivBtn').onclick = loadPriv;
  </script>
</body>
</html>
